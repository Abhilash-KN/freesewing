var freesewing_patterns_brian =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../freesewing/dist/index.js":
/*!***********************************!*\
  !*** ../freesewing/dist/index.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar freesewing_1 = __webpack_require__(/*! ./lib/freesewing */ \"../freesewing/dist/lib/freesewing.js\");\n\nvar freesewing = new freesewing_1.Freesewing(); //svg.pre('loadStyle', function (next) {\n//  console.log('loadStyle hook');\n//  console.log(this.style);\n//  this.style= 'p {line-height: 1.21;}';\n//  console.log('logging in hook', this);\n//  next();\n//});\n//var p = new app.pattern({parts:['tst']});\n//p.draft = function(){\n//  console.log('drafting in lib index');\n//}\n//p.draft();\n//p.render();\n\nexports.default = freesewing;\n\n//# sourceURL=webpack://freesewing_patterns_brian/../freesewing/dist/index.js?");

/***/ }),

/***/ "../freesewing/dist/lib/attributes.js":
/*!********************************************!*\
  !*** ../freesewing/dist/lib/attributes.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Attributes =\n/*#__PURE__*/\nfunction () {\n  function Attributes() {\n    _classCallCheck(this, Attributes);\n\n    this.list = {};\n  }\n  /** Adds an attribute */\n\n\n  _createClass(Attributes, [{\n    key: \"add\",\n    value: function add(name, value) {\n      if (typeof this.list[name] === 'undefined') {\n        this.list[name] = [];\n      }\n\n      this.list[name].push(value);\n      return this;\n    }\n    /** Retrieves an attribute */\n\n  }, {\n    key: \"get\",\n    value: function get(name) {\n      return this.list[name].join(' ');\n    }\n    /** Returns SVG code for attributes */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var svg = '';\n\n      for (var key in this.list) {\n        var attrs = this.list;\n        svg += \" \".concat(key, \"=\\\"\").concat(this.list[key].join(' '), \"\\\"\");\n      }\n\n      return svg;\n    }\n  }]);\n\n  return Attributes;\n}();\n\nexports.Attributes = Attributes;\n\n//# sourceURL=webpack://freesewing_patterns_brian/../freesewing/dist/lib/attributes.js?");

/***/ }),

/***/ "../freesewing/dist/lib/freesewing.js":
/*!********************************************!*\
  !*** ../freesewing/dist/lib/freesewing.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar __importStar = void 0 && (void 0).__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar pattern_1 = __webpack_require__(/*! ./pattern */ \"../freesewing/dist/lib/pattern.js\");\n\nvar point_1 = __webpack_require__(/*! ./point */ \"../freesewing/dist/lib/point.js\");\n\nvar path_1 = __webpack_require__(/*! ./path */ \"../freesewing/dist/lib/path.js\");\n\nvar snippet_1 = __webpack_require__(/*! ./snippet */ \"../freesewing/dist/lib/snippet.js\");\n\nvar utils = __importStar(__webpack_require__(/*! ./utils */ \"../freesewing/dist/lib/utils.js\"));\n\nvar Freesewing = function Freesewing() {\n  _classCallCheck(this, Freesewing);\n\n  this.version = '1.0.1';\n  this.pattern = pattern_1.Pattern;\n  this.point = point_1.Point;\n  this.path = path_1.Path;\n  this.snippet = snippet_1.Snippet;\n  this.utils = utils;\n};\n\nexports.Freesewing = Freesewing;\n\n//# sourceURL=webpack://freesewing_patterns_brian/../freesewing/dist/lib/freesewing.js?");

/***/ }),

/***/ "../freesewing/dist/lib/hooks.js":
/*!***************************************!*\
  !*** ../freesewing/dist/lib/hooks.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Hooks =\n/*#__PURE__*/\nfunction () {\n  function Hooks(app) {\n    _classCallCheck(this, Hooks);\n\n    this._hooks = {};\n    this.all = ['preRenderSvg', 'postRenderSvg'];\n  } ///** Add hook */\n  //on(hook, method): void {\n  //  // This gets called from the pattern context\n  //  // so 'this' is not actually this class\n  //  let self = this.hooks;\n  //  if(typeof self._hooks[method] === 'undefined') {\n  //    self._hooks[hook] = [];\n  //  }\n  //  self._hooks[hook].push(method);\n  //}\n\n\n  _createClass(Hooks, [{\n    key: \"list\",\n    value: function list(hook) {\n      if (typeof this._hooks[hook] === 'undefined') {\n        return false;\n      }\n\n      return this._hooks[hook];\n    }\n  }, {\n    key: \"attachPre\",\n    value: function attachPre(hook, obj) {\n      this._attach('pre', hook, obj);\n    }\n  }, {\n    key: \"attachPost\",\n    value: function attachPost(hook, obj) {\n      this._attach('post', hook, obj);\n    }\n  }, {\n    key: \"attach\",\n    value: function attach(hook, obj) {\n      if (typeof this._hooks[hook] === 'undefined') return;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this._hooks[hook][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var func = _step.value;\n          obj.pre(hook, func);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }]);\n\n  return Hooks;\n}();\n\nexports.Hooks = Hooks;\n\n//# sourceURL=webpack://freesewing_patterns_brian/../freesewing/dist/lib/hooks.js?");

/***/ }),

/***/ "../freesewing/dist/lib/part.js":
/*!**************************************!*\
  !*** ../freesewing/dist/lib/part.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar __importDefault = void 0 && (void 0).__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar point_1 = __webpack_require__(/*! ./point */ \"../freesewing/dist/lib/point.js\");\n\nvar path_1 = __webpack_require__(/*! ./path */ \"../freesewing/dist/lib/path.js\");\n\nvar attributes_1 = __webpack_require__(/*! ./attributes */ \"../freesewing/dist/lib/attributes.js\");\n\nvar hooks_1 = __importDefault(__webpack_require__(/*! hooks */ \"../freesewing/node_modules/hooks/hooks.js\"));\n\nvar Part =\n/*#__PURE__*/\nfunction () {\n  function Part(id) {\n    _classCallCheck(this, Part);\n\n    this.points = {};\n    this.paths = {};\n    this.snippets = {};\n    this.attributes = new attributes_1.Attributes(); // Expose constructors for macros\n\n    this.point = point_1.Point;\n    this.path = path_1.Path;\n    this.id = id;\n    this.render = id.substr(0, 1) === '_' ? false : true;\n    this.points.origin = new point_1.Point(0, 0);\n\n    for (var k in hooks_1.default) {\n      this[k] = hooks_1.default[k];\n    }\n\n    return this;\n  }\n\n  _createClass(Part, [{\n    key: \"macroRunner\",\n    value: function macroRunner(args) {\n      console.log('arguments in macroRunner', arguments);\n      var self = this;\n      var data = args;\n\n      var method = function method(key, data) {\n        var macro = \"_macro_\".concat(key);\n\n        if (typeof self[macro] === 'function') {\n          self[macro](data);\n        }\n      };\n\n      return method;\n    }\n  }]);\n\n  return Part;\n}();\n\nexports.Part = Part;\n\n//# sourceURL=webpack://freesewing_patterns_brian/../freesewing/dist/lib/part.js?");

/***/ }),

/***/ "../freesewing/dist/lib/path.js":
/*!**************************************!*\
  !*** ../freesewing/dist/lib/path.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar attributes_1 = __webpack_require__(/*! ./attributes */ \"../freesewing/dist/lib/attributes.js\");\n\nvar Path =\n/*#__PURE__*/\nfunction () {\n  function Path() {\n    _classCallCheck(this, Path);\n\n    this.render = true;\n    this.ops = [];\n    this.attributes = new attributes_1.Attributes();\n  }\n  /** Adds a move operation to Point to */\n\n\n  _createClass(Path, [{\n    key: \"move\",\n    value: function move(to) {\n      this.ops.push({\n        type: \"move\",\n        to: to\n      });\n      return this;\n    }\n    /** Adds a line operation to Point to */\n\n  }, {\n    key: \"line\",\n    value: function line(to) {\n      this.ops.push({\n        type: \"line\",\n        to: to\n      });\n      return this;\n    }\n    /** Adds a line operation to Point to */\n\n  }, {\n    key: \"curve\",\n    value: function curve(cp1, cp2, to) {\n      this.ops.push({\n        type: \"curve\",\n        cp1: cp1,\n        cp2: cp2,\n        to: to\n      });\n      return this;\n    }\n    /** Adds a close operation */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      this.ops.push({\n        type: \"close\"\n      });\n      return this;\n    }\n    /** Adds an attribute. This is here to make this call chainable in assignment */\n\n  }, {\n    key: \"attr\",\n    value: function attr(name, value) {\n      this.attributes.add(name, value);\n      return this;\n    }\n    /** Returns SVG pathstring for this path */\n\n  }, {\n    key: \"asPathstring\",\n    value: function asPathstring() {\n      var d = '';\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.ops[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var op = _step.value;\n\n          switch (op.type) {\n            case 'move':\n              d += \"M \".concat(op.to.x, \",\").concat(op.to.y);\n              break;\n\n            case 'line':\n              d += \" L \".concat(op.to.x, \",\").concat(op.to.y);\n              break;\n\n            case 'curve':\n              d += \" C \".concat(op.cp1.x, \",\").concat(op.cp1.y, \" \").concat(op.cp2.x, \",\").concat(op.cp2.y, \" \").concat(op.to.x, \",\").concat(op.to.y);\n              break;\n\n            case 'close':\n              d += ' z';\n              break;\n\n            default:\n              throw \"\".concat(op.type, \" is not a valid path command\");\n              break;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return d;\n    }\n  }]);\n\n  return Path;\n}();\n\nexports.Path = Path;\n\n//# sourceURL=webpack://freesewing_patterns_brian/../freesewing/dist/lib/path.js?");

/***/ }),

/***/ "../freesewing/dist/lib/pattern.js":
/*!*****************************************!*\
  !*** ../freesewing/dist/lib/pattern.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar point_1 = __webpack_require__(/*! ./point */ \"../freesewing/dist/lib/point.js\");\n\nvar part_1 = __webpack_require__(/*! ./part */ \"../freesewing/dist/lib/part.js\");\n\nvar svg_1 = __webpack_require__(/*! ./svg */ \"../freesewing/dist/lib/svg.js\");\n\nvar hooks_1 = __webpack_require__(/*! ./hooks */ \"../freesewing/dist/lib/hooks.js\");\n\nvar snippet_1 = __webpack_require__(/*! ./snippet */ \"../freesewing/dist/lib/snippet.js\");\n\nvar path_1 = __webpack_require__(/*! ./path */ \"../freesewing/dist/lib/path.js\");\n\nvar Pattern =\n/*#__PURE__*/\nfunction () {\n  function Pattern(config) {\n    _classCallCheck(this, Pattern);\n\n    this.values = {};\n    this.settings = {\n      mode: 'draft',\n      units: 'metric'\n    };\n\n    if (!config) {\n      throw \"Could not create pattern: You need to provide a pattern config.\";\n    }\n\n    if (typeof config.parts === 'undefined' || !config.parts || config.parts.length < 1) {\n      throw \"Could not create pattern: You should define at least one part in your pattern config\";\n    }\n\n    this.config = config;\n    this.point = point_1.Point;\n    this.path = path_1.Path;\n    this.snippet = snippet_1.Snippet;\n    this.parts = {};\n    this.svg = new svg_1.Svg(this);\n    this.hooks = new hooks_1.Hooks();\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = config.parts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var id = _step.value;\n        this.parts[id] = new part_1.Part(id);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    this.options = {};\n\n    if (typeof config.options !== 'undefined' && config.options.length > 0) {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = config.options[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var conf = _step2.value;\n          if (conf.type === 'percentage') this.options[conf.id] = conf.val / 100;else this.options[conf.id] = conf.val;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n\n    this.context = {\n      parts: this.parts,\n      options: this.options,\n      values: this.values,\n      config: this.config,\n      settings: this.settings\n    };\n    return this;\n  }\n\n  _createClass(Pattern, [{\n    key: \"draft\",\n    value: function draft() {\n      throw Error('You have to implement the draft() method in your Pattern instance.');\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      this.hooks.attach('preRenderSvg', this.svg);\n      this.hooks.attach('postRenderSvg', this.svg);\n      return this.svg.render(this);\n    }\n  }, {\n    key: \"on\",\n    value: function on(hook, method) {\n      if (typeof this.hooks._hooks[hook] === 'undefined') {\n        this.hooks._hooks[hook] = [];\n      }\n\n      this.hooks._hooks[hook].push(method);\n    }\n  }, {\n    key: \"macro\",\n    value: function macro(key, method) {\n      var name = \"_macro_\".concat(key);\n      this.on(name, method);\n\n      for (var partId in this.parts) {\n        var part = this.parts[partId];\n\n        part[name] = function () {\n          return null;\n        };\n\n        this.hooks.attach(name, part);\n      }\n    }\n  }, {\n    key: \"loadPlugin\",\n    value: function loadPlugin(plugin) {\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = this.hooks.all[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var hook = _step3.value;\n\n          if (typeof plugin[hook] === 'function') {\n            this.on(hook, plugin[hook]);\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n  }]);\n\n  return Pattern;\n}();\n\nexports.Pattern = Pattern;\n\n//# sourceURL=webpack://freesewing_patterns_brian/../freesewing/dist/lib/pattern.js?");

/***/ }),

/***/ "../freesewing/dist/lib/point.js":
/*!***************************************!*\
  !*** ../freesewing/dist/lib/point.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar utils_1 = __webpack_require__(/*! ./utils */ \"../freesewing/dist/lib/utils.js\");\n\nvar attributes_1 = __webpack_require__(/*! ./attributes */ \"../freesewing/dist/lib/attributes.js\");\n\nvar Point =\n/*#__PURE__*/\nfunction () {\n  function Point(x, y) {\n    _classCallCheck(this, Point);\n\n    this.attributes = new attributes_1.Attributes();\n    this.x = utils_1.round(x);\n    this.y = utils_1.round(y);\n    return this;\n  }\n  /** Returns the distance between this point and that point */\n\n\n  _createClass(Point, [{\n    key: \"dist\",\n    value: function dist(that) {\n      var dx = this.x - that.x;\n      var dy = this.y - that.y;\n      return utils_1.round(Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)));\n    }\n    /** Returns slope of a line made by this point and that point */\n\n  }, {\n    key: \"slope\",\n    value: function slope(that) {\n      return (that.y - this.y) / (that.x - this.x);\n    }\n    /** Returns the x-delta between this point and that point */\n\n  }, {\n    key: \"dx\",\n    value: function dx(that) {\n      return that.x - this.x;\n    }\n    /** Returns the y-delta between this point and that point */\n\n  }, {\n    key: \"dy\",\n    value: function dy(that) {\n      return that.y - this.y;\n    }\n    /** Returns the angle between this point and that point */\n\n  }, {\n    key: \"angle\",\n    value: function angle(that) {\n      var rad = Math.atan2(-1 * this.dy(that), this.dx(that));\n\n      while (rad < 0) {\n        rad += 2 * Math.PI;\n      }\n\n      return utils_1.rad2deg(rad);\n    }\n    /** Rotate this point deg around that point */\n\n  }, {\n    key: \"rotate\",\n    value: function rotate(deg, that) {\n      var radius = this.dist(that);\n      var angle = this.angle(that);\n      var x = that.x + radius * Math.cos(utils_1.deg2rad(angle + deg)) * -1;\n      var y = that.y + radius * Math.sin(utils_1.deg2rad(angle + deg));\n      return new Point(x, y);\n    }\n    /** returns an identical copy of this point */\n\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      return new Point(this.x, this.y);\n    }\n    /** checks whether this point is equal to that point */\n\n  }, {\n    key: \"equals\",\n    value: function equals(that) {\n      return this.x === that.x && this.y === that.y ? true : false;\n    }\n    /** Mirrors this point around X value of that point */\n\n  }, {\n    key: \"flipX\",\n    value: function flipX(that) {\n      return new Point(that.x + this.dx(that), that.y);\n    }\n    /** Mirrors this point around Y value of that point */\n\n  }, {\n    key: \"flipY\",\n    value: function flipY(that) {\n      return new Point(that.x, that.y + this.dy(that));\n    }\n    /** Shifts this point distance in the deg direction */\n\n  }, {\n    key: \"shift\",\n    value: function shift(deg, distance) {\n      var p = this.copy();\n      p.x += distance;\n      return p.rotate(deg, this);\n    }\n    /** Shifts this point distance in the direction of that point */\n\n  }, {\n    key: \"shiftTowards\",\n    value: function shiftTowards(that, distance) {\n      return this.shift(this.angle(that), distance);\n    }\n    /** Shifts this point fraction of the distance towards that point */\n\n  }, {\n    key: \"shiftFractionTowards\",\n    value: function shiftFractionTowards(that, fraction) {\n      return this.shiftTowards(that, this.dist(that) * fraction);\n    }\n    /** Shifts this point distance beyond that point */\n\n  }, {\n    key: \"shiftOutwards\",\n    value: function shiftOutwards(that, distance) {\n      return this.shiftTowards(that, this.dist(that) + distance);\n    }\n  }]);\n\n  return Point;\n}();\n\nexports.Point = Point;\n\n//# sourceURL=webpack://freesewing_patterns_brian/../freesewing/dist/lib/point.js?");

/***/ }),

/***/ "../freesewing/dist/lib/snippet.js":
/*!*****************************************!*\
  !*** ../freesewing/dist/lib/snippet.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar attributes_1 = __webpack_require__(/*! ./attributes */ \"../freesewing/dist/lib/attributes.js\");\n\nvar Snippet = function Snippet(anchor, def) {\n  var description = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  _classCallCheck(this, Snippet);\n\n  this.attributes = new attributes_1.Attributes();\n  this.anchor = anchor;\n  this.def = def;\n  this.description = description;\n  return this;\n};\n\nexports.Snippet = Snippet;\n\n//# sourceURL=webpack://freesewing_patterns_brian/../freesewing/dist/lib/snippet.js?");

/***/ }),

/***/ "../freesewing/dist/lib/svg.js":
/*!*************************************!*\
  !*** ../freesewing/dist/lib/svg.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar __importDefault = void 0 && (void 0).__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar attributes_1 = __webpack_require__(/*! ./attributes */ \"../freesewing/dist/lib/attributes.js\");\n\nvar hooks_1 = __importDefault(__webpack_require__(/*! hooks */ \"../freesewing/node_modules/hooks/hooks.js\"));\n\nvar Svg =\n/*#__PURE__*/\nfunction () {\n  function Svg(pattern) {\n    _classCallCheck(this, Svg);\n\n    this.body = '';\n    this.style = '';\n    this.script = '';\n    this.header = '';\n    this.footer = '';\n    this.defs = '';\n    this.attributes = new attributes_1.Attributes();\n    this.tabs = 0;\n    this.freeId = 1;\n    this.svg = '';\n    this.openGroups = [];\n    this.pattern = pattern; // Needed to expose pattern to hooks\n\n    this.prefix = '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>';\n    this.attributes.add(\"xmlns\", \"http://www.w3.org/2000/svg\");\n    this.attributes.add(\"xmlns:svg\", \"http://www.w3.org/2000/svg\");\n    this.attributes.add(\"xmlns:xlink\", \"http://www.w3.org/1999/xlink\");\n    this.hooks = ['preRenderSvg', 'postRenderSvg'];\n\n    for (var k in hooks_1.default) {\n      this[k] = hooks_1.default[k];\n    }\n\n    for (var _k in this.hooks) {\n      this.hook(_k, this[_k]);\n    }\n\n    return this;\n  }\n  /** Method to attach preRenderSvg hooks on */\n\n\n  _createClass(Svg, [{\n    key: \"preRenderSvg\",\n    value: function preRenderSvg() {}\n    /** Method to attach postRenderSvg hooks on */\n\n  }, {\n    key: \"postRenderSvg\",\n    value: function postRenderSvg() {}\n    /** Renders a draft object as SVG */\n\n  }, {\n    key: \"render\",\n    value: function render(pattern) {\n      this.preRenderSvg();\n      this.svg = this.prefix;\n      this.svg += this.renderComments(this.header);\n      this.svg += this.renderSvgTag(pattern);\n      this.svg += this.renderStyle();\n      this.svg += this.renderScript();\n      this.svg += this.renderDefs();\n      this.svg += this.openGroup('draftContainer');\n\n      for (var partId in pattern.parts) {\n        var part = pattern.parts[partId];\n\n        if (part.render) {\n          this.svg += this.openGroup(part.id, part.attributes);\n          this.svg += this.renderPart(part);\n          this.svg += this.closeGroup();\n        }\n      }\n\n      this.svg += this.closeGroup();\n      this.svg += this.nl() + '</svg>';\n      this.svg += this.renderComments(this.footer);\n      this.postRenderSvg();\n      return this.svg;\n    }\n    /** Returns SVG code for the opening SVG tag */\n\n  }, {\n    key: \"renderSvgTag\",\n    value: function renderSvgTag(pattern) {\n      var svg = '<svg';\n      this.indent();\n      svg += this.nl() + this.attributes.render();\n      this.outdent();\n      svg += this.nl() + '>' + this.nl();\n      return svg;\n    }\n    /** Returns SVG code for the style block */\n\n  }, {\n    key: \"renderStyle\",\n    value: function renderStyle() {\n      var svg = '<style type=\"text/css\"> <![CDATA[ ';\n      this.indent();\n      svg += this.nl() + this.style;\n      this.outdent();\n      svg += this.nl() + ']]>' + this.nl() + '</style>' + this.nl();\n      return svg;\n    }\n    /** Returns SVG code for the script block */\n\n  }, {\n    key: \"renderScript\",\n    value: function renderScript() {\n      var svg = '<script type=\"text/javascript\"> <![CDATA[';\n      this.indent();\n      svg += this.nl() + this.script;\n      this.outdent();\n      svg += this.nl() + ']]>' + this.nl() + '</script>' + this.nl();\n      return svg;\n    }\n    /** Returns SVG code for the defs block */\n\n  }, {\n    key: \"renderDefs\",\n    value: function renderDefs() {\n      var svg = '<defs id=\"defs\">';\n      this.indent();\n      svg += this.nl() + this.defs;\n      this.outdent();\n      svg += this.nl() + '</defs>' + this.nl();\n      return svg;\n    }\n    /** Returns SVG code for a comment block */\n\n  }, {\n    key: \"renderComments\",\n    value: function renderComments(comments) {\n      return this.nl() + this.nl() + '<!--' + this.nl() + comments + this.nl() + '-->';\n    }\n    /** Returns SVG code for a Part object */\n\n  }, {\n    key: \"renderPart\",\n    value: function renderPart(part) {\n      var svg = '';\n\n      for (var key in part.paths) {\n        var path = part.paths[key];\n        if (path.render) svg += this.renderPath(path);\n      }\n\n      for (var _key in part.snippets) {\n        var snippet = part.snippets[_key];\n        svg += this.renderSnippet(snippet);\n      } // includes\n      // text on path\n      // notes\n      // dimensions\n      // texts\n\n\n      return svg;\n    }\n    /** Returns SVG code for a Path object */\n\n  }, {\n    key: \"renderPath\",\n    value: function renderPath(path) {\n      path.attributes.add('d', path.asPathstring());\n      return \"\".concat(this.nl(), \"<path \").concat(path.attributes.render(), \" />\");\n    }\n    /** Returns SVG code for a snippet */\n\n  }, {\n    key: \"renderSnippet\",\n    value: function renderSnippet(snippet) {\n      var svg = this.nl();\n      svg += \"<use x=\\\"\".concat(snippet.anchor.x, \"\\\" y=\\\"\").concat(snippet.anchor.y, \"\\\" \");\n      svg += \"xlink:href=\\\"#\".concat(snippet.def, \"\\\" \").concat(snippet.attributes.render(), \">\");\n\n      if (snippet.description) {\n        svg += \"<title>\".concat(snippet.description, \"</title>\");\n      }\n\n      svg += '</use>';\n      return svg;\n    }\n    /** Returns SVG code to open a group */\n\n  }, {\n    key: \"openGroup\",\n    value: function openGroup(id, attributes) {\n      var svg = this.nl() + this.nl();\n      svg += \"<!-- Start of group #\".concat(id, \" -->\");\n      svg += this.nl();\n      svg += \"<g id=\\\"\".concat(id, \"\\\">\");\n      this.indent();\n      this.openGroups.push(id);\n      return svg;\n    }\n    /** Returns SVG code to close a group */\n\n  }, {\n    key: \"closeGroup\",\n    value: function closeGroup() {\n      this.outdent();\n      return \"\".concat(this.nl(), \"</g>\").concat(this.nl(), \"<!-- end of group #\").concat(this.openGroups.pop(), \" -->\");\n    }\n    /** Returns a linebreak + identation */\n\n  }, {\n    key: \"nl\",\n    value: function nl() {\n      return \"\\n\" + this.tab();\n    }\n    /** Returns indentation */\n\n  }, {\n    key: \"tab\",\n    value: function tab() {\n      var space = '';\n\n      for (var i = 0; i < this.tabs; i++) {\n        space += '  ';\n      }\n\n      return space;\n    }\n    /** Increases indentation by 1 */\n\n  }, {\n    key: \"indent\",\n    value: function indent() {\n      this.tabs += 1;\n    }\n    /** Decreases indentation by 1 */\n\n  }, {\n    key: \"outdent\",\n    value: function outdent() {\n      this.tabs -= 1;\n    }\n    /** Returns an unused ID */\n\n  }, {\n    key: \"getUid\",\n    value: function getUid() {\n      this.freeId += 1;\n      return '' + this.freeId;\n    }\n  }]);\n\n  return Svg;\n}();\n\nexports.Svg = Svg;\n\n//# sourceURL=webpack://freesewing_patterns_brian/../freesewing/dist/lib/svg.js?");

/***/ }),

/***/ "../freesewing/dist/lib/utils.js":
/*!***************************************!*\
  !*** ../freesewing/dist/lib/utils.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar point_1 = __webpack_require__(/*! ./point */ \"../freesewing/dist/lib/point.js\");\n/** Rounds a value to PRECISION */\n\n\nfunction round(value) {\n  return Math.round(value * 1e2) / 1e2;\n}\n\nexports.round = round;\n/** Radians to degrees */\n\nfunction rad2deg(radians) {\n  return radians * 57.29577951308232;\n}\n\nexports.rad2deg = rad2deg;\n/** Degrees to radians */\n\nfunction deg2rad(degrees) {\n  return degrees / 57.29577951308232;\n}\n\nexports.deg2rad = deg2rad;\n/** Find intersection of two (endless) lines */\n\nfunction beamsCross(a1, a2, b1, b2) {\n  var slopeA = a1.slope(a2);\n  var slopeB = b1.slope(b2);\n  if (slopeA === slopeB) return false; // Parallel lines\n\n  if (a1.x === a2.x) return new point_1.Point(a1.x, slopeB * a1.x + (b1.y - slopeB * b1.x)); // Vertical line A\n  else if (b1.x === b2.x) return new point_1.Point(b1.x, slopeA * b1.x + (a1.y - slopeA * a1.x)); // Vertical line B\n    else {\n        // Swap points if line A or B goes from right to left\n        if (a1.x > a2.x) {\n          var tmp = a1.copy();\n          a1 = a2.copy();\n          a2 = tmp;\n        }\n\n        if (b1.x > b2.x) {\n          var _tmp = b1.copy();\n\n          b1 = b2.copy();\n          b2 = _tmp;\n        } // Find y intercept\n\n\n        var iA = a1.y - slopeA * a1.x;\n        var iB = b1.y - slopeB * b1.x; // Find intersection\n\n        var x = (iB - iA) / (slopeA - slopeB);\n        var y = slopeA * x + iA;\n        return new point_1.Point(x, y);\n      }\n}\n\nexports.beamsCross = beamsCross;\n/** Find intersection of two line segments */\n\nfunction linesCross(a1, a2, b1, b2) {\n  var p = beamsCross(a1, a2, b1, b2);\n\n  if (p) {\n    var lenA = a1.dist(a2);\n    var lenB = b1.dist(b2);\n    var lenC = a1.dist(p) + p.dist(a2);\n    var lenD = b1.dist(p) + p.dist(b2);\n    if (round(lenA) == round(lenC) && round(lenB) == round(lenD)) return p;\n  }\n\n  return false;\n}\n\nexports.linesCross = linesCross;\n/** Find where an (endless) line crosses a certain Y-value */\n\nfunction beamCrossesY(from, to, y) {\n  if (from.y === to.y) return false; // Horizontal line\n\n  var left = new point_1.Point(-10, y);\n  var right = new point_1.Point(10, y);\n  return beamsCross(from, to, left, right);\n}\n\nexports.beamCrossesY = beamCrossesY;\n/** Returns an object with shorthand access for pattern design */\n\nfunction shorthand(part, context) {\n  var final = context.settings.mode === 'draft' ? true : false;\n  var paperless = context.settings.paperless === true ? true : false;\n  return {\n    measurements: context.settings.measurements || {},\n    options: context.options || {},\n    values: context.values || {},\n    points: part.points || {},\n    paths: part.paths || {},\n    snippets: part.snippets || {},\n    macro: part.macroRunner(),\n    final: final,\n    paperless: paperless\n  };\n}\n\nexports.shorthand = shorthand;\n\n//# sourceURL=webpack://freesewing_patterns_brian/../freesewing/dist/lib/utils.js?");

/***/ }),

/***/ "../freesewing/node_modules/hooks/hooks.js":
/*!*************************************************!*\
  !*** ../freesewing/node_modules/hooks/hooks.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// TODO Add in pre and post skipping options\nmodule.exports = {\n  /**\n   *  Declares a new hook to which you can add pres and posts\n   *  @param {String} name of the function\n   *  @param {Function} the method\n   *  @param {Function} the error handler callback\n   */\n  hook: function (name, fn, errorCb) {\n    if (arguments.length === 1 && typeof name === 'object') {\n      for (var k in name) { // `name` is a hash of hookName->hookFn\n        this.hook(k, name[k]);\n      }\n      return;\n    }\n\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {}\n      , posts = proto._posts = proto._posts || {};\n    pres[name] = pres[name] || [];\n    posts[name] = posts[name] || [];\n\n    proto[name] = function () {\n      var self = this\n        , hookArgs // arguments eventually passed to the hook - are mutable\n        , lastArg = arguments[arguments.length-1]\n        , pres = this._pres[name]\n        , posts = this._posts[name]\n        , _total = pres.length\n        , _current = -1\n        , _asyncsLeft = proto[name].numAsyncPres\n        , _next = function () {\n            if (arguments[0] instanceof Error) {\n              return handleError(arguments[0]);\n            }\n            var _args = Array.prototype.slice.call(arguments)\n              , currPre\n              , preArgs;\n            if (_args.length && !(arguments[0] == null && typeof lastArg === 'function'))\n              hookArgs = _args;\n            if (++_current < _total) {\n              currPre = pres[_current]\n              if (currPre.isAsync && currPre.length < 2)\n                throw new Error(\"Your pre must have next and done arguments -- e.g., function (next, done, ...)\");\n              if (currPre.length < 1)\n                throw new Error(\"Your pre must have a next argument -- e.g., function (next, ...)\");\n              preArgs = (currPre.isAsync\n                          ? [once(_next), once(_asyncsDone)]\n                          : [once(_next)]).concat(hookArgs);\n              return currPre.apply(self, preArgs);\n            } else if (!proto[name].numAsyncPres) {\n              return _done.apply(self, hookArgs);\n            }\n          }\n        , _done = function () {\n            var args_ = Array.prototype.slice.call(arguments)\n              , ret, total_, current_, next_, done_, postArgs;\n\n            if (_current === _total) {\n              \n              next_ = function () {\n                if (arguments[0] instanceof Error) {\n                  return handleError(arguments[0]);\n                }\n                var args_ = Array.prototype.slice.call(arguments, 1)\n                  , currPost\n                  , postArgs;\n                if (args_.length) hookArgs = args_;\n                if (++current_ < total_) {\n                  currPost = posts[current_]\n                  if (currPost.length < 1)\n                    throw new Error(\"Your post must have a next argument -- e.g., function (next, ...)\");\n                  postArgs = [once(next_)].concat(hookArgs);\n                  return currPost.apply(self, postArgs);\n                } else if (typeof lastArg === 'function'){\n                  // All post handlers are done, call original callback function\n                  return lastArg.apply(self, arguments);\n                }\n              };\n\n              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting\n              // a callback.  We trap that callback and wait to call it until all post handlers have finished.\n              if(typeof lastArg === 'function'){\n                args_[args_.length - 1] = once(next_);\n              }\n\n              total_ = posts.length;\n              current_ = -1;\n              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward\n\n              if (total_ && typeof lastArg !== 'function') return next_();  // no callback provided, execute next_() manually\n              return ret;\n            }\n          };\n      if (_asyncsLeft) {\n        function _asyncsDone (err) {\n          if (err && err instanceof Error) {\n            return handleError(err);\n          }\n          --_asyncsLeft || _done.apply(self, hookArgs);\n        }\n      }\n      function handleError (err) {\n        if ('function' == typeof lastArg)\n          return lastArg(err);\n        if (errorCb) return errorCb.call(self, err);\n        throw err;\n      }\n      return _next.apply(this, arguments);\n    };\n    \n    proto[name].numAsyncPres = 0;\n\n    return this;\n  },\n\n  pre: function (name, isAsync, fn, errorCb) {\n    if ('boolean' !== typeof arguments[1]) {\n      errorCb = fn;\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , pres = proto._pres = proto._pres || {};\n\n    this._lazySetupHooks(proto, name, errorCb);\n\n    if (fn.isAsync = isAsync) {\n      proto[name].numAsyncPres++;\n    }\n\n    (pres[name] = pres[name] || []).push(fn);\n    return this;\n  },\n  post: function (name, isAsync, fn) {\n    if (arguments.length === 2) {\n      fn = isAsync;\n      isAsync = false;\n    }\n    var proto = this.prototype || this\n      , posts = proto._posts = proto._posts || {};\n    \n    this._lazySetupHooks(proto, name);\n    (posts[name] = posts[name] || []).push(fn);\n    return this;\n  },\n  removePre: function (name, fnToRemove) {\n    var proto = this.prototype || this\n      , pres = proto._pres || (proto._pres || {});\n    if (!pres[name]) return this;\n    if (arguments.length === 1) {\n      // Remove all pre callbacks for hook `name`\n      pres[name].length = 0;\n    } else {\n      pres[name] = pres[name].filter( function (currFn) {\n        return currFn !== fnToRemove;\n      });\n    }\n    return this;\n  },\n  _lazySetupHooks: function (proto, methodName, errorCb) {\n    if ('undefined' === typeof proto[methodName].numAsyncPres) {\n      this.hook(methodName, proto[methodName], errorCb);\n    }\n  }\n};\n\nfunction once (fn, scope) {\n  return function fnWrapper () {\n    if (fnWrapper.hookCalled) return;\n    fnWrapper.hookCalled = true;\n    return fn.apply(scope, arguments);\n  };\n}\n\n\n//# sourceURL=webpack://freesewing_patterns_brian/../freesewing/node_modules/hooks/hooks.js?");

/***/ }),

/***/ "./config/config.js":
/*!**************************!*\
  !*** ./config/config.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/** Pattern parts */\nmodule.exports = {\n  parts: [\"back\", \"front\", \"_sleeve\"],\n  measurements: [\"bicepsCircumference\", \"centerBackNeckToWaist\", \"chestCircumference\", \"naturalWaistToHip\", \"neckCircumference\", \"shoulderSlope\", \"shoulderToShoulder\", \"hipsCircumference\", \"shoulderToWrist\", \"wristCircumference\"],\n  options: [// Constants\n  {\n    \"id\": \"backNeckCutout\",\n    \"val\": 20,\n    \"type\": \"constant\"\n  }, {\n    \"id\": \"bicepsEase\",\n    \"val\": 50,\n    \"type\": \"constant\"\n  }, {\n    \"id\": \"collarEase\",\n    \"val\": 15,\n    \"type\": \"constant\"\n  }, {\n    \"id\": \"frontArmholeExtra\",\n    \"val\": 5,\n    \"type\": \"constant\"\n  }, {\n    \"id\": \"shoulderSlopeReduction\",\n    \"val\": 0,\n    \"type\": \"constant\"\n  }, {\n    \"id\": \"sleevecapEase\",\n    \"val\": 5,\n    \"type\": \"constant\"\n  }, {\n    \"id\": \"collarFactor\",\n    \"val\": 4.8,\n    \"type\": \"constant\"\n  }, // Measures\n  {\n    \"id\": \"bicepsEase\",\n    \"val\": 50,\n    \"min\": 30,\n    \"max\": 80\n  }, {\n    \"id\": \"chestEase\",\n    \"val\": 30,\n    \"min\": -40,\n    \"max\": 160\n  }, {\n    \"id\": \"shoulderEase\",\n    \"val\": 0,\n    \"min\": -20,\n    \"max\": 60\n  }, {\n    \"id\": \"cuffEase\",\n    \"val\": 45,\n    \"min\": 0,\n    \"max\": 100\n  }, {\n    \"id\": \"lengthBonus\",\n    \"val\": 0,\n    \"min\": -40,\n    \"max\": 120\n  }, {\n    \"id\": \"sleeveLengthBonus\",\n    \"val\": 0,\n    \"min\": -40,\n    \"max\": 80\n  }, // Percentages\n  {\n    \"id\": \"acrossBackFactor\",\n    \"val\": 96,\n    \"type\": \"percentage\",\n    \"min\": 93,\n    \"max\": 99\n  }, {\n    \"id\": \"armholeDepthFactor\",\n    \"val\": 50,\n    \"type\": \"percentage\",\n    \"min\": 35,\n    \"max\": 65\n  }, {\n    \"id\": \"sleevecapHeightFactor\",\n    \"val\": 55,\n    \"type\": \"percentage\",\n    \"min\": 35,\n    \"max\": 75\n  }]\n};\n\n//# sourceURL=webpack://freesewing_patterns_brian/./config/config.js?");

/***/ }),

/***/ "./src/back.js":
/*!*********************!*\
  !*** ./src/back.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _freesewing = _interopRequireDefault(__webpack_require__(/*! freesewing */ \"../freesewing/dist/index.js\"));\n\nvar _base = _interopRequireDefault(__webpack_require__(/*! ./base */ \"./src/base.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar back = {\n  draft: function draft(part, context) {\n    var _F$utils$shorthand = _freesewing.default.utils.shorthand(part, context),\n        measurements = _F$utils$shorthand.measurements,\n        options = _F$utils$shorthand.options,\n        points = _F$utils$shorthand.points,\n        paths = _F$utils$shorthand.paths,\n        snippets = _F$utils$shorthand.snippets,\n        macro = _F$utils$shorthand.macro,\n        final = _F$utils$shorthand.final,\n        paperless = _F$utils$shorthand.paperless;\n\n    console.log('shorthand', _freesewing.default.utils.shorthand(part, context));\n\n    _base.default.draft(part, context);\n\n    paths.seam = new _freesewing.default.path().move(points.cbNeck).line(points.cbHips).line(points.hips).line(points.armhole).curve(points.armholeCp1, points.armholeCp2, points.armholeHollow).curve(points.armholeHollowCp1, points.armholeHollowCp2, points.armholePitch).curve(points.armholePitchCp1, points.armholePitchCp2, points.shoulder).line(points.neck).curve(points.neckCp1, points.cbNeck, points.cbNeck).close(); // Final?\n\n    var decorate = function decorate(part, context) {\n      macro('cof', {\n        from: points.cbNeck,\n        to: points.cbHips\n      });\n    };\n\n    if (final) {\n      decorate(part, context);\n    } // Paperless?\n\n\n    var gauge = function gauge(part, context) {};\n\n    if (paperless) {\n      gauge(part, context);\n    }\n  }\n};\nvar _default = back;\nexports.default = _default;\n\n//# sourceURL=webpack://freesewing_patterns_brian/./src/back.js?");

/***/ }),

/***/ "./src/base.js":
/*!*********************!*\
  !*** ./src/base.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _freesewing = _interopRequireDefault(__webpack_require__(/*! freesewing */ \"../freesewing/dist/index.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar base = {\n  draft: function draft(part, context) {\n    var _F$utils$shorthand = _freesewing.default.utils.shorthand(part, context),\n        measurements = _F$utils$shorthand.measurements,\n        options = _F$utils$shorthand.options,\n        points = _F$utils$shorthand.points,\n        paths = _F$utils$shorthand.paths,\n        snippets = _F$utils$shorthand.snippets; // Center back (cb) vertical axis\n\n\n    points.cbNeck = new _freesewing.default.point(0, options.backNeckCutout);\n    points.cbShoulder = new _freesewing.default.point(0, (measurements.shoulderSlope - options.shoulderSlopeReduction) / 2);\n    points.cbArmhole = new _freesewing.default.point(0, points.cbShoulder.y + (measurements.bicepsCircumference + options.bicepsEase) * options.armholeDepthFactor);\n    points.cbWaist = new _freesewing.default.point(0, measurements.centerBackNeckToWaist + options.backNeckCutout);\n    points.cbHips = new _freesewing.default.point(0, points.cbWaist.y + measurements.naturalWaistToHip); // Side back (cb) vertical axis\n\n    points.armhole = new _freesewing.default.point(measurements.chestCircumference / 4 + options.chestEase / 4, points.cbArmhole.y);\n    points.waist = new _freesewing.default.point(points.armhole.x, points.cbWaist.y);\n    points.hips = new _freesewing.default.point(points.armhole.x, points.cbHips.y); // Shoulder line\n\n    points.neck = new _freesewing.default.point(measurements.neckCircumference / options.collarFactor, 0);\n    points.shoulder = new _freesewing.default.point(measurements.shoulderToShoulder / 2 + options.shoulderEase / 2, points.cbShoulder.y); // Armhhole\n\n    points.armholePitch = new _freesewing.default.point(measurements.shoulderToShoulder * options.acrossBackFactor / 2, points.shoulder.y + points.shoulder.dy(points.armhole) / 2);\n    points._tmp1 = new _freesewing.default.point(points.armholePitch.x, points.armhole.y);\n    points._tmp2 = points._tmp1.shift(45, 10);\n    points._tmp3 = _freesewing.default.utils.beamsCross(points._tmp1, points._tmp2, points.armhole, points.armholePitch);\n    points.armholeHollow = points._tmp1.shiftFractionTowards(points._tmp3, 0.5);\n    points.armholeCp1 = points.armhole.shift(180, points._tmp1.dx(points.armhole) / 4);\n    points.armholeCp2 = points.armholeHollow.shift(-45, points.armholeHollow.dy(points.armhole) / 2);\n    points.armholeHollowCp1 = points.armholeHollow.shift(135, points.armholePitch.dx(points.armholeHollow));\n    points.armholeHollowCp2 = points.armholePitch.shift(-90, points.armholePitch.dy(points.armholeHollow) / 2);\n    points.armholePitchCp1 = points.armholePitch.shift(90, points.shoulder.dy(points.armholePitch) / 2);\n    points.armholePitchCp2 = points.shoulder.shiftTowards(points.neck, points.shoulder.dy(points.armholePitch) / 5).rotate(90, points.shoulder); // Neck opening\n\n    points._tmp4 = points.neck.shiftTowards(points.shoulder, 10).rotate(-90, points.neck);\n    points.neckCp1 = _freesewing.default.utils.beamCrossesY(points.neck, points._tmp4, points.cbNeck.y);\n    points.neckCp2 = points.cbNeck.shift(0, points.cbNeck.dx(points.neck) / 2);\n  }\n};\nvar _default = base;\nexports.default = _default;\n\n//# sourceURL=webpack://freesewing_patterns_brian/./src/base.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _freesewing = _interopRequireDefault(__webpack_require__(/*! freesewing */ \"../freesewing/dist/index.js\"));\n\nvar patternConfig = _interopRequireWildcard(__webpack_require__(/*! ../config/config */ \"./config/config.js\"));\n\nvar _back = _interopRequireDefault(__webpack_require__(/*! ./back */ \"./src/back.js\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar brian = new _freesewing.default.pattern(patternConfig);\n\nbrian.draft = function () {\n  _back.default.draft(brian.parts.back, brian.context);\n\n  return brian;\n};\n\nmodule.exports = brian;\n\n//# sourceURL=webpack://freesewing_patterns_brian/./src/index.js?");

/***/ })

/******/ });